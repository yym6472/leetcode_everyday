## 题意

- 链接：[https://www.lintcode.com/problem/burst-balloons/description](https://www.lintcode.com/problem/burst-balloons/description)

这道题的题意为，有`n`个气球，编号为`0, ..., n-1`，排成一排。每个气球有一个非负分数，存放在`nums`数组中。每次吹爆一个气球，可以获得其本身、其左边气球、其右边气球
分数的乘积，即`score = nums[left] * nums[i] * nums[right]`的得分。当改气球被吹爆时，其原本的左右气球就视为相邻。当一个气球的左边/右边没有气球时，
认为其左边和右边气球的分数都为`1`。求吹爆所有气球能够获得的最高分。

## 题解

这道题是区间DP，这类DP的特点是，使用二维数组`dp[i][j]`来表示区间`[i, j]`的子问题最优解（即DP的状态）。其动态规划转移方程有一个特点，就是
从小区间（即大区间的若干子区间）递推到大区间，最后算出`dp[0][n-1]`的解。

回到这道题，如果用常规的思维去思考吹爆气球的顺序，容易把自己绕晕。这里的核心在于：
1. 定义子问题：吹爆所有区间`[i, j]`内气球能够获得的最高分（这里需要假设第`i-1`个气球和第`j+1`个气球未被吹爆）；
2. 把目光聚集在最后一步，即吹爆`[i, j]`内所有气球中的**最后一个气球**，假设这个气球为`k`，那么在吹爆`k`之前，`[i, k-1]`的气球和`[k+1, j]`的气球都已经被吹爆了，他们能够获得的最高分即`dp[i][k-1]`和`dp[k+1][j]`；
3. 由于`k`是`[i, j]`内最后一个被吹爆的气球，所以在吹爆`k`之前，气球的情况应该是`..., i-1, k, j+1, ...`，所以吹爆`k`能够获得的分数为`nums[i-1] * nums[k] * nums[j+1]`；
4. 因此区间`[i, j]`上的子问题可以枚举最后一个被吹爆的气球`k = i ... j`，然后分别计算他们的总分，取最大得分即可，转移方程为：`dp[i][j] = max(dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1])`，当然这里需要对`k = i`或`k = j`的特殊情况做一个特判。

初始化：`dp[i][i] = nums[i] * nums[i-1] * nums[i+1]`即可，记得在数组前后添加`1`。