## 题意

- 链接：[https://www.lintcode.com/problem/find-median-from-data-stream/description](https://www.lintcode.com/problem/find-median-from-data-stream/description)

题意为：从不断到来的数据流中维护当前的中位数。也就是需要在每次新的一个数到来的同时，返回新的中位数。这里的中位数指的是排序后数组的中间值，即`A[(n-1) / 2]`。
当数据总数为偶数时，返回的是中间靠前的那个元素，而不是中间两个数的平均。

## 分析

先来复习一下给定数组求中位数（或者进一步推广：求第`k`大的数）的做法。求数组中中位数（或第`k`大的数）时，可以采用减治法（即快速排序的变种，每次partition后只取其中一支进行递归操作）。这种情况下，算法的平均时间复杂度
为`O(n)`，最坏时间情况下的时间复杂度为`O(n^2)`。

而当数据是逐个到来（数据流），而我们需要不断维护当前的中位数时，最粗暴的算法就是每当一个数据到来时，进行一次求中位数的算法。这种情况下，假设数据流的大小为`n`，每次求中位数的平均时间复杂度为`O(n)`，
总共的平均时间复杂度为`O(n^2)`。

另一种直观的做法是维护一个有序的列表，当新数据到来时，插入到合适的位置以维持列表的有序结构，在查询时只需找到中间那个数即可。数据结构上可以使用两种：
- 数组：每次维护（插入）需要时间`O(n)`；
- 链表：每次维护（找到插入位置）需要时间`O(n)`；

因此两种方法均需要`O(n^2)`的时间复杂度。显然这道题需要优于`O(n^2)`的解法

## 解法

使用两个堆。其中大顶堆（堆顶为最大值）保存较小的那一半数据；小顶堆（堆顶为最小值）保存较大的那一半数据。
每当一个新数据到来时，判断两个堆的大小，以及新到来数据和目前两个堆堆顶数据的相对大小，进行调整：
- 两个堆大小相同，且新到来的数小于等于大顶堆的堆顶：将新到来的数加入大顶堆；
- 两个堆大小相同，且新到来的数大于大顶堆的堆顶：将新到来的数加入小顶堆，然后从小顶堆弹出堆顶元素，放入大顶堆；
- 大顶堆比小顶堆多1，且新到来的数小于等于大顶堆的堆顶：将新到来的数加入大顶堆，然后从大顶堆弹出堆顶元素，放入小顶堆；
- 大顶堆比小顶堆多1，且新到来的数大于大顶堆的堆顶：将新到来的数加入小顶堆。

## Follow Up

1. 数据流中维护第`k`大/第`k`小/前`k`大/前`k`小的数？
   
   Solution：对于第`k`大数，维护一个小顶堆，保存最大的`k`个数即可；对于第`k`小数，维护一个大顶堆，保存最小的`k`个数即可。

2. 数据流中维护前`x%`的数？
   
   Solution：同样维护两个堆即可，不过在新数据到达时需要维护两个堆分别占有`x%`和`(100-x)%`的数据。